<h1 align="center">
<strong>1.0 Overview</strong><br>
</h1>

- NestJS는 이미 만들어진 기능들을 제공함<br>
  ex) nest-cli존재, package.json에서 미리 만들어진 스크립트들 존재<br>
  타입스크립트 설정과 빌드 설정되어 있음,<br>
  test폴더 존재,<br>
  src폴더 - controller, _spec파일)삭제 후 시작_, module, service, main존재

_package.json_

```
"start": "nest start",
"start:dev": "nest start --watch",
"start:debug": "nest start --debug --watch",
"start:prod": "node dist/main",
```

=> 4가지의 존재 확인 후, 작동하는지 먼저 봄<br>
=> npm run start:dev<br>
=> Nest 어플리케이션을 시작함(successfully started)<br>
=> localhost:3000 진입 가능

_폴더) src 분석_

- NestJS는 <strong>main.ts파일 반드시 가짐</strong>. (이름 정확히)

_main.ts_

```typescript
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
```

=> bootstrap함수 ) _이름은 상관없음_<br>
=> await NestFactory.create(<strong>AppModule</strong>)을 호출 + 3000번을 호출

_app.module.ts_

=> AppModule이 class

```typescript
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

=> @ ) 데코레이터

> NestJS는 데코레이터와 함께 함<br>
> 데코레이터 ) class에 함수기능 추가 가능

=> export class AppModule {} 는 비어있음<br>
=> BUT! @Module에 import, <strong>controllers</strong>, providers 존재

_app.controller.ts_

```typescript
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

- @Get()
  => string을 리턴하는 getHello함수 존재<br>
  => 여기서 appService 는<br>
  => appService: <strong>AppService</strong>임.

_app.service.ts_

```typescript
@Injectable()
export class AppService {
  getHello(): string {
    return "Hello World!";
  }
}
```

=> getHello()함수 얻음<br>
=> "Hello World!"를 리턴

<h3> <strong>즉, main.ts -> 모듈 -> 컨트롤러 -> 서비스 -> 텍스트 변경가능/strong><br></h3>

<h1 align="center">
<strong>1.1 Controllers </strong><br>
</h1>

- NestJS ) main.ts에서 시작

_main.ts_

- 하나의 모듈(AppModule)에서 어플리케이션 생성
  => AppModule ) 루트 모듈
- 모듈 ) 어플리케이션의 일부분
- controllers ) url가져오고 함수를 실행하는 것

_app.controller.ts_

- 컨트롤러 = express.js의 controller/router와 같음

  > express.js ) 라우터에서 app.get + 함수 사용

  ```typescript
  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
  ```

- @Get ) express의 get라우터와 같은 역할
- 데코레이터 ) 꾸며주는 함수나 클래스와 붙어있어야 함

  > 데코레이터와 함수사이 빈줄 두지 않기

  - ex)

    ```typescript
      @Post('/hello')
    sayHello(): string {
    return 'Hello oooo';
    }
    ```

    => http://localhost:3000/hello<br>
    => Get일 경우, Hello oooo 보임<br>
    => Post이니, 에러 보임<br>

    > url을 가져와서 함수로 매핑,<br>
    > /hello가 seyHello함수 실행함

=> NestJs에서는 라우터를 세팅하지 않아도 됨<br>
=> Get, post...자동

- BUT! @Get에서 Service를 리턴함
